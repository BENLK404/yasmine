<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üíñYasmine - Univers Immersif üíñ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Impact', 'Arial Black', sans-serif;
            touch-action: none;
            cursor: grab;
        }

        body.grabbing {
            cursor: grabbing;
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.3) 100%);
            pointer-events: none;
            z-index: 5;
        }

        .name-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            perspective: 1000px;
            width: 90%;
            pointer-events: none;
        }

        .name {
            font-size: clamp(50px, 15vw, 150px);
            font-weight: 900;
            letter-spacing: 0.1em;
            background: linear-gradient(45deg,
            #ff0080, #ff8c00, #40e0d0, #9d00ff,
            #ff0080, #ff8c00, #40e0d0);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation:
                    megaGradient 4s ease infinite,
                    explosive 6s ease-in-out infinite;
            filter:
                    drop-shadow(0 0 40px rgba(255, 0, 128, 0.9))
                    drop-shadow(0 0 60px rgba(157, 0, 255, 0.7))
                    drop-shadow(0 0 80px rgba(64, 224, 208, 0.5));
            transform-style: preserve-3d;
        }

        @keyframes megaGradient {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 50% 0%; }
        }

        @keyframes explosive {
            0%, 100% {
                transform: scale(1) translateY(0) rotateX(0deg);
            }
            25% {
                transform: scale(1.15) translateY(-30px) rotateX(15deg);
            }
            50% {
                transform: scale(0.95) translateY(0) rotateX(-10deg);
            }
            75% {
                transform: scale(1.1) translateY(-20px) rotateX(10deg);
            }
        }

        .particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .subtitle {
            margin-top: clamp(20px, 5vh, 50px);
            font-size: clamp(18px, 4vw, 32px);
            color: white;
            font-weight: bold;
            animation: pulse 2s ease-in-out infinite;
            text-shadow:
                    0 0 20px rgba(255, 255, 255, 1),
                    0 0 40px rgba(255, 0, 128, 0.8),
                    0 0 60px rgba(157, 0, 255, 0.6);
            letter-spacing: 0.2em;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }

        .stars {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }

        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
            box-shadow: 0 0 10px white;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        .lightning {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            animation: flash 5s infinite;
        }

        @keyframes flash {
            0%, 90%, 100% { opacity: 0; }
            92%, 94%, 96% { opacity: 0.8; }
        }

        .ring {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            margin: -100px 0 0 -100px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: expandRing 3s ease-out infinite;
            z-index: 4;
            pointer-events: none;
        }

        @keyframes expandRing {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .controls {
            position: fixed;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 20;
            background: rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .control-btn {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(135deg, #ff0080, #9d00ff);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: clamp(0.8rem, 2vw, 1rem);
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(255, 0, 128, 0.5);
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 128, 0.8);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .zoom-indicator {
            position: fixed;
            top: 5%;
            right: 5%;
            color: white;
            font-size: clamp(0.8rem, 2vw, 1rem);
            background: rgba(0,0,0,0.7);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            z-index: 20;
            font-family: 'Courier New', monospace;
            border: 2px solid rgba(255,255,255,0.2);
            text-shadow: 0 0 10px rgba(255,0,128,0.8);
        }

        .instructions {
            position: fixed;
            top: 5%;
            left: 5%;
            color: white;
            font-size: clamp(0.7rem, 1.8vw, 0.9rem);
            background: rgba(0,0,0,0.7);
            padding: 1rem;
            border-radius: 15px;
            z-index: 20;
            font-family: 'Arial', sans-serif;
            border: 2px solid rgba(255,255,255,0.2);
            max-width: 250px;
            line-height: 1.5;
        }

        .explosion-particle {
            position: fixed;
            pointer-events: none;
            z-index: 15;
            animation: explode 1s ease-out forwards;
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .name {
                font-size: clamp(40px, 12vw, 80px);
            }

            .controls {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.8rem 1.5rem;
            }

            .control-btn {
                padding: 0.6rem 1rem;
            }

            .instructions {
                font-size: 0.7rem;
                padding: 0.8rem;
                max-width: 180px;
            }
        }
    </style>
</head>
<body>
<canvas id="canvas3d"></canvas>
<canvas class="particles-canvas" id="particlesCanvas"></canvas>
<div class="overlay"></div>
<div class="stars" id="starsContainer"></div>
<div class="lightning"></div>
<div class="ring"></div>
<div class="ring" style="animation-delay: 1s;"></div>
<div class="ring" style="animation-delay: 2s;"></div>

<div class="name-container">
    <div class="subtitle">‚òÖ Yasmine's Univers ‚òÖ</div>
</div>

<div class="instructions">
    üñ±Ô∏è Glisser pour tourner<br>
    üîç Molette/Pincer pour zoomer<br>
    üëÜ Cliquer pour explosions<br>
    üéØ Boutons pour vues rapides
</div>

<div class="zoom-indicator">
    ZOOM: <span id="zoomLevel">100%</span>
</div>

<div class="controls">
    <button class="control-btn" id="resetBtn">üîÑ Reset</button>
    <button class="control-btn" id="closeBtn">üîç Rapprocher</button>
    <button class="control-btn" id="farBtn">üåå √âloigner</button>
    <button class="control-btn" id="topBtn">‚¨ÜÔ∏è Vue Haut</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // √âtoiles scintillantes
    const starsContainer = document.getElementById('starsContainer');
    for (let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        star.style.animationDuration = (Math.random() * 2 + 2) + 's';
        starsContainer.appendChild(star);
    }

    // Canvas pour particules
    const particlesCanvas = document.getElementById('particlesCanvas');
    const pCtx = particlesCanvas.getContext('2d');
    particlesCanvas.width = window.innerWidth;
    particlesCanvas.height = window.innerHeight;

    const particles = [];
    class Particle {
        constructor() {
            this.reset();
        }
        reset() {
            this.x = Math.random() * particlesCanvas.width;
            this.y = Math.random() * particlesCanvas.height;
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
            this.life = Math.random() * 100 + 100;
            this.maxLife = this.life;
            this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            this.size = Math.random() * 3 + 1;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            if (this.life <= 0) this.reset();
        }
        draw() {
            pCtx.globalAlpha = this.life / this.maxLife;
            pCtx.fillStyle = this.color;
            pCtx.shadowBlur = 20;
            pCtx.shadowColor = this.color;
            pCtx.beginPath();
            pCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            pCtx.fill();
        }
    }

    for (let i = 0; i < 150; i++) {
        particles.push(new Particle());
    }

    function animateParticles() {
        pCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
        particles.forEach(p => {
            p.update();
            p.draw();
        });
        requestAnimationFrame(animateParticles);
    }
    animateParticles();

    // Three.js - Configuration
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('canvas3d'),
        alpha: true,
        antialias: !isMobile
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    camera.position.z = 30;

    // G√©om√©tries complexes avec possibilit√© de zoom
    const geometries = [
        new THREE.IcosahedronGeometry(8, 1),
        new THREE.TorusGeometry(8, 3, 16, 100),
        new THREE.OctahedronGeometry(10, 0),
        new THREE.TetrahedronGeometry(7, 0),
        new THREE.DodecahedronGeometry(6, 0)
    ];

    const mainMeshes = [];
    geometries.forEach((geom, i) => {
        const colors = [0xff0080, 0x40e0d0, 0x9d00ff, 0xff8c00, 0x00ff00];
        const mat = new THREE.MeshPhongMaterial({
            color: colors[i],
            wireframe: true,
            transparent: true,
            opacity: 0.4,
            emissive: colors[i],
            emissiveIntensity: 0.5
        });
        const mesh = new THREE.Mesh(geom, mat);
        const angle = (i / geometries.length) * Math.PI * 2;
        mesh.position.x = Math.cos(angle) * 15;
        mesh.position.y = Math.sin(angle) * 15;
        mesh.position.z = -10 - i * 3;
        mesh.userData = { originalPosition: mesh.position.clone() };
        mainMeshes.push(mesh);
        scene.add(mesh);
    });

    // Nuage de points lumineux
    const pointsGeometry = new THREE.BufferGeometry();
    const pointsCount = isMobile ? 2000 : 3000;
    const positions = new Float32Array(pointsCount * 3);
    const colors = new Float32Array(pointsCount * 3);

    for (let i = 0; i < pointsCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 100;
        positions[i + 1] = (Math.random() - 0.5) * 100;
        positions[i + 2] = (Math.random() - 0.5) * 100;

        const color = new THREE.Color();
        color.setHSL(Math.random(), 1, 0.7);
        colors[i] = color.r;
        colors[i + 1] = color.g;
        colors[i + 2] = color.b;
    }

    pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    pointsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const pointsMaterial = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    const pointsCloud = new THREE.Points(pointsGeometry, pointsMaterial);
    scene.add(pointsCloud);

    // Lumi√®res dynamiques
    const lights = [];
    const lightColors = [0xff0080, 0x40e0d0, 0x9d00ff, 0xff8c00, 0x00ff00];
    for (let i = 0; i < 5; i++) {
        const light = new THREE.PointLight(lightColors[i], 2, 100);
        lights.push(light);
        scene.add(light);
    }

    const ambientLight = new THREE.AmbientLight(0x222222);
    scene.add(ambientLight);

    // Variables de contr√¥le
    let time = 0;
    let mouseX = 0;
    let mouseY = 0;
    let targetX = 0;
    let targetY = 0;
    let targetZoom = 30;
    let currentZoom = 30;
    let isDragging = false;
    let previousMouse = { x: 0, y: 0 };
    let rotationX = 0;
    let rotationY = 0;

    // Gestion du drag
    const canvas = document.getElementById('canvas3d');

    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        document.body.classList.add('grabbing');
        previousMouse = { x: e.clientX, y: e.clientY };
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            previousMouse = { x: e.clientX, y: e.clientY };
        } else {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.classList.remove('grabbing');
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        document.body.classList.remove('grabbing');
    });

    // Touch events
    let touchDistance = 0;
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = true;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            touchDistance = Math.sqrt(dx * dx + dy * dy);
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 1 && isDragging) {
            const deltaX = e.touches[0].clientX - previousMouse.x;
            const deltaY = e.touches[0].clientY - previousMouse.y;
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const delta = distance - touchDistance;
            targetZoom -= delta * 0.05;
            targetZoom = Math.max(5, Math.min(100, targetZoom));
            touchDistance = distance;
        }
    });

    canvas.addEventListener('touchend', () => {
        isDragging = false;
    });

    // Zoom avec molette
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        targetZoom += e.deltaY * 0.05;
        targetZoom = Math.max(5, Math.min(100, targetZoom));
    }, { passive: false });

    // Boutons de contr√¥le
    document.getElementById('resetBtn').addEventListener('click', () => {
        targetZoom = 30;
        rotationX = 0;
        rotationY = 0;
        camera.position.set(0, 0, 30);
    });

    document.getElementById('closeBtn').addEventListener('click', () => {
        targetZoom = 10;
    });

    document.getElementById('farBtn').addEventListener('click', () => {
        targetZoom = 60;
    });

    document.getElementById('topBtn').addEventListener('click', () => {
        rotationX = -Math.PI / 4;
        rotationY = 0;
    });

    // Mise √† jour du zoom indicator
    function updateZoomIndicator() {
        const zoomPercent = Math.round((30 / currentZoom) * 100);
        document.getElementById('zoomLevel').textContent = zoomPercent + '%';
    }

    // Animation principale
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        // Zoom fluide
        currentZoom += (targetZoom - currentZoom) * 0.1;

        // Position de la cam√©ra avec rotation
        const radius = currentZoom;
        camera.position.x = Math.sin(rotationY) * Math.cos(rotationX) * radius;
        camera.position.y = Math.sin(rotationX) * radius;
        camera.position.z = Math.cos(rotationY) * Math.cos(rotationX) * radius;

        // Mouvement subtil si pas de drag
        if (!isDragging) {
            targetX += (mouseX - targetX) * 0.05;
            targetY += (mouseY - targetY) * 0.05;
            camera.position.x += targetX * 2;
            camera.position.y += -targetY * 2;
        }

        camera.lookAt(scene.position);
        updateZoomIndicator();

        // Animation des formes
        mainMeshes.forEach((mesh, i) => {
            mesh.rotation.x = time * (0.5 + i * 0.2);
            mesh.rotation.y = time * (0.3 + i * 0.1);
            mesh.rotation.z = time * 0.1;
            mesh.position.y = mesh.userData.originalPosition.y + Math.sin(time + i) * 5;
            mesh.scale.set(
                1 + Math.sin(time * 2 + i) * 0.3,
                1 + Math.cos(time * 2 + i) * 0.3,
                1 + Math.sin(time + i) * 0.3
            );
        });

        // Animation du nuage
        pointsCloud.rotation.y = time * 0.1;
        pointsCloud.rotation.x = time * 0.05;

        // Animation des lumi√®res
        lights.forEach((light, i) => {
            const angle = time + (i * Math.PI * 2 / lights.length);
            light.position.x = Math.cos(angle) * 20;
            light.position.y = Math.sin(angle * 1.5) * 20;
            light.position.z = Math.sin(angle) * 20;
            light.intensity = 2 + Math.sin(time * 3 + i) * 1;
        });

        renderer.render(scene, camera);
    }
    animate();

    // Effet explosion au clic
    function createExplosion(x, y) {
        for (let i = 0; i < 30; i++) {
            const particle = document.createElement('div');
            particle.className = 'explosion-particle';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.width = (Math.random() * 8 + 4) + 'px';
            particle.style.height = particle.style.width;
            particle.style.background = `hsl(${Math.random() * 360}, 100%, 70%)`;
            particle.style.borderRadius = '50%';
            particle.style.boxShadow = `0 0 10px ${particle.style.background}`;

            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 200 + 100;
            particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
            particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');

            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }

        // Particules canvas
        for (let i = 0; i < 20; i++) {
            const p = new Particle();
            p.x = x;
            p.y = y;
            p.vx = (Math.random() - 0.5) * 10;
            p.vy = (Math.random() - 0.5) * 10;
            p.size = Math.random() * 5 + 2;
            particles.push(p);
        }
    }

    canvas.addEventListener('click', (e) => createExplosion(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches[0] && e.touches.length === 1) {
            setTimeout(() => {
                if (!isDragging) {
                    createExplosion(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, 100);
        }
    });

    // Responsive
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        particlesCanvas.width = window.innerWidth;
        particlesCanvas.height = window.innerHeight;
    });
</script>
</body>
</html>